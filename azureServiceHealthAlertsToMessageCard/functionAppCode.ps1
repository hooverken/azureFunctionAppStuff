# adaptiveCard.ps1 (for Azure Powershell function app) 
# by Ken Hoover <kendothooveratmicrosoftdotcom>
# Original version August 2019
# Reimplemented for Kentoso.us demo/lab environment April 2022
# Revised to use Adaptive Cards Jan 2024

# CHANGELOG
# 05 May 2022 KH - Dump full JSON payload to generated card (for debugging, will remove later)
# 06 Jun 2022 KH - Use message title as the title of the card
# 02 Feb 2024 KH - Switch from messageCard to Adaptive card format and add support for resource health alerts
#
# This is Powershell code for an Azure function app to parse an incoming webhook generated by a Service 
# Health alert and turn it into a MessageCard which is then sent to a destination such as Teams via an outgoing 
# webhook.  It can probably be adapted fairly easily to send webhooks to other recipients like Slack.

# This code was based on a lot of experimentation.  it can probably be mode more bulletproof but it is functional
# Use at your own risk.

# This assumes that the incoming webhook uses the Common Alert Schema.
# It is built to work with Azure Service Health alerts AND Resource Health Alerts
# https://docs.microsoft.com/en-us/azure/azure-monitor/platform/alerts-common-schema-definitions#monitoringservice--servicehealth

#
# IMPORTANT:  Read HOW_TO_IMPLEMENT.md in this repo for a summary of how to configure this properly.

using namespace System.Net

# Incoming data from the trigger
param ( $Request ) # This is the incoming webhook payload


# Helper Functions

Function Select-EmphasisColor {
    param (
        [string]$stage,
        [string]$level
    )
    switch ($level) {
        "Informational" { 
            $color = "accent"
            switch ($stage) {
                "Active" {
                    $color = "attention"
                }
                "Resolved" {
                    $color = "good"
                }
                "RCA" {
                    $color = "good"
                }
                Default {
                    $color = "accent"
                }
            }
        }
        "ActionRequired" {
            $color = "attention"
        }
        "Downtime" {
            $color = "attention"
        }
        "Incident" {  # apply different themes based on the alert stage.
            switch ($stage) {
                "Active" {
                    $color = "attention"
                }
                "Resolved" {
                    $color = "good"
                }
                "RCA" {
                    $color = "good"
                }
                Default {
                    $color = "accent"
                }
            }
        }
        "Maintenance" {
            switch ($stage) {
                "Active" {
                    $color = "attention"
                }
                "Planned" {
                    $color = "good"
                }
                "Complete" {
                    $color = "good"
                }
                Default {
                    $color = "accent"
                }
            }
        }
        "Security" {      
            switch ($stage) {
                "Active" {
                    $color = "attention"
                }
                "Resolved" {
                    $color = "good"
                }
                "RCA" {
                    $color = "good"
                }
                Default {
                    $color = "accent"
                }
            }
        }
        Default {
            $color = "attention"
        }
    }

    return $color
}

function chooseIconForAlertCard {

    param (
        [string]$severity
    )
    
    # These URLs point to PNG icons that will be displayed next to the title of the message card
    # The icons I'm using here were downloaded from https://icon-icons.com but there are tons of free ones out there.
    # The access level to the container should be set to "Blob (anonymous read access for blobs only)"

    $informationalIconUri = 'https://kenhoover.blob.core.windows.net/servicehealthalerticons/information.png'
    $actionRequiredIconUri = 'https://kenhoover.blob.core.windows.net/servicehealthalerticons/redactiontriangleicon.png'
    $incidentIconUri = 'https://kenhoover.blob.core.windows.net/servicehealthalerticons/warning.png'
    $maintenanceIconUri = 'https://kenhoover.blob.core.windows.net/servicehealthalerticons/maintenance.png'
    $securityIconUri = 'https://kenhoover.blob.core.windows.net/servicehealthalerticons/shield.png'
    $defaultIconUri = 'https://kenhoover.blob.core.windows.net/servicehealthalerticons/information.png'

    switch ($severity) {
        "Sev1" {
            $iconUrl = $actionRequiredIconUri
        }
        "Sev2" {
            $iconUrl = $incidentIconUri
        }
        "Sev3" {
            $iconUrl = $incidentIconUri
        }
        "Sev4" {  
            $iconUrl = $informationalIconUri
        }
        Default { # in case something comes through that we don't recognize
            $iconUrl = $defaultIconUri
        }
    }  

    return $iconUrl

}

# End of Functions ------------------------

# Some setup stuff

# Get the payload from the incoming webhook as an object
$payload = $Request.rawbody | ConvertFrom-Json

Write-Output ($payload | ConvertTo-Json -Depth 20)  # Dump payload so it shows up in the run log

# Check if this is a service health alert or resource health alert
$isServiceHealthAlert = ($payload.data.essentials.monitoringService -eq "ServiceHealth") ? $true : $false

# Get the subscription ID that this alert is for from the payload

if ($payload.data.essentials.alertTargetIDs.count -gt 1) {
    # If there is more than one alert target then we will look at the first element to get the subscription ID
    # This is the case for resource health alerts
    $subscriptionId = $payload.data.essentials.alertTargetIDs[0].split('/')[4] 
} else {
    # If there is only one alert target then we can just parse the alertTargetIDs array to get the subscription ID
    # This is the case for service health alerts
    $subscriptionId = $payload.data.essentials.alertTargetIDs.split('/')[2] 
}

# Write something to the Azure Functions log stream to show we are alive
$isServiceHealthAlert ? (Write-Output "Processing Service Health Alert for subscription $subscriptionId") : (Write-Output "Processing Resource Health Alert for subscription $subscriptionId")

# ------------------  Build the the header/title section  ------------------

# The title of the card - a one-line summary of what's happening
if ($isServiceHealthAlert) {
    # Ex:  "Active/Investigating:  Azure Monitor - East US - Service Degradation"
    $titleText =  $payload.data.alertContext.properties.IncidentType + "/" + $payload.data.alertContext.properties.stage + ": " + $payload.data.alertContext.properties.title
} else {
    # ex: "TESTVM000: Reboot initiated from inside the machine"
    $titleText =  $payload.data.essentials.configurationItems[0] + ": " + $payload.data.alertContext.properties.title
}

# Service health and resource health use different schemas so we need to get the stage and level from different places
$eventStage = ($isServiceHealthAlert ? $payload.data.alertContext.properties.stage : $payload.data.alertContext.properties.cause)
$eventLevel = ($isServiceHealthAlert ? $payload.data.alertContext.level.IncidentType : $payload.data.alertContext.level)

$title = New-Object -TypeName psobject
$title | Add-Member -MemberType NoteProperty -Name 'type' -Value 'TextBlock'
$title | Add-Member -MemberType NoteProperty -Name 'text' -Value $titleText
$title | Add-Member -MemberType NoteProperty -Name 'spacing' -Value 'none'
$title | Add-Member -MemberType NoteProperty -Name 'weight' -Value 'bolder'
$title | Add-Member -MemberType NoteProperty -Name 'style' -Value 'heading'
$title | Add-Member -MemberType NoteProperty -Name 'size' -Value 'large'
$title | Add-Member -MemberType NoteProperty -Name 'wrap' -Value $true
$title | Add-Member -MemberType NoteProperty -Name 'color' -Value (Select-EmphasisColor -stage $eventStage -level $eventLevel)

# Add the details about what's affected for the header section
$details1Text = ($isServiceHealthAlert ? $payload.data.alertContext.properties.service : $payload.data.alertContext.properties.cause)

# Details Section #1
$details1 = New-Object -TypeName psobject
$details1 | Add-Member -MemberType NoteProperty -Name 'type' -Value 'TextBlock'
$details1 | Add-Member -MemberType NoteProperty -Name 'text' -Value $details1Text
$details1 | Add-Member -MemberType NoteProperty -Name 'spacing' -Value 'none'
$details1 | Add-Member -MemberType NoteProperty -Name 'weight' -Value 'bolder'
$details1 | Add-Member -MemberType NoteProperty -Name 'style' -Value 'heading'
$details1 | Add-Member -MemberType NoteProperty -Name 'size' -Value 'large'
$details1 | Add-Member -MemberType NoteProperty -Name 'wrap' -Value $true


# Details section #2 - either the service name (if this is a service health alert) or the RG name if it's a resource health alert

if ($isServiceHealthAlert) {
    # for a service health alert I'm more interested in the affected regioin
    $details2Text = "Region: " + $payload.data.alertContext.properties.region
} else {
    # if this is a resource health alert I'm more interested in when it happened.
    $details2Text = "Detected: " + $payload.data.essentials.firedDateTime
}

$details2 = New-Object -TypeName psobject
$details2 | Add-Member -MemberType NoteProperty -Name 'type' -Value 'TextBlock'
$details2 | Add-Member -MemberType NoteProperty -Name 'text' -Value $details2Text
$details2 | Add-Member -MemberType NoteProperty -Name 'spacing' -Value 'none'
$details2 | Add-Member -MemberType NoteProperty -Name 'weight' -Value 'bolder'
$details2 | Add-Member -MemberType NoteProperty -Name 'style' -Value 'heading'
$details2 | Add-Member -MemberType NoteProperty -Name 'size' -Value 'medium'
$details2 | Add-Member -MemberType NoteProperty -Name 'wrap' -Value $true

# The affected subscription ID
$severity = New-Object -TypeName psobject
$severity | Add-Member -MemberType NoteProperty -Name 'type' -Value 'TextBlock'
$severity | Add-Member -MemberType NoteProperty -Name 'text' -Value ("Subscription: " + $subscriptionId)
$severity | Add-Member -MemberType NoteProperty -Name 'spacing' -Value 'none'
$severity | Add-Member -MemberType NoteProperty -Name 'size' -Value 'medium'
$severity | Add-Member -MemberType NoteProperty -Name 'wrap' -Value $true


# Choose what icon should be associated with this card

$iconUrl = chooseIconForAlertCard($payload.data.essentials.severity)

$iconProperties = New-Object -TypeName psobject
$iconProperties | Add-Member -MemberType NoteProperty -Name 'type' -Value 'Image'
$iconProperties | Add-Member -MemberType NoteProperty -Name 'url' -Value $iconUrl
$iconProperties | Add-Member -MemberType NoteProperty -Name 'altText' -Value $payload.data.essentials.severity
$iconProperties | Add-Member -MemberType NoteProperty -Name 'size' -Value 'Medium'

$iconSection = New-Object -type psobject
$iconSection | Add-Member -MemberType NoteProperty -Name 'type' -Value 'Column'
$iconSection | Add-Member -MemberType NoteProperty -Name 'width' -Value 'auto'
$iconSection | Add-Member -MemberType NoteProperty -Name 'items' -Value @($iconProperties)


$titleSection = New-Object -TypeName psobject
$titleSection | Add-Member -MemberType NoteProperty -Name 'type' -Value 'Column'
$titleSection | Add-Member -MemberType NoteProperty -Name 'items' -Value @($title, $details1,$details2, $severity)

$headerSection = New-Object -TypeName psobject
$headerSection | Add-Member -MemberType NoteProperty -Name 'type' -Value 'ColumnSet'
$headerSection | Add-Member -MemberType NoteProperty -Name 'columns' -Value @($iconSection, $titleSection)

# ------------------  Build the Description section (easy)  ------------------

# This is the block of text with the full description of what's happening.

$descriptionText = ($isServiceHealthAlert ? $payload.data.alertContext.properties.defaultLanguageContent : $payload.data.alertContext.properties.details)

# If the descriptionText comes back as null just use the alert title as the description.
if ($null -eq $descriptionText) {
    $descriptionText = $titleText
}

$detailsSection = New-Object -TypeName psobject
$detailsSection | Add-Member -MemberType NoteProperty -Name 'type' -Value 'TextBlock'
$detailsSection | Add-Member -MemberType NoteProperty -Name 'text' -Value $descriptionText
$detailsSection | Add-Member -MemberType NoteProperty -Name 'wrap' -Value $true  # Word wrap this text

# ------------------  Build the Fact Set (details of the alert) ------------------

$factsList = [System.Collections.ArrayList]::new()

if ($isServiceHealthAlert) {
    # Skip posting information from the facts list that is redundant or messy
    $propertiesToSkip = @("title", "impactedServices","communication","DefaultLanguageTitle","defaultLanguageContent","impactedServicesTableRows")

    # Copy the properties of the payload (a list of name-value pairs) into the card's "facts" section
    $facts = $payload.data.alertcontext.properties
    if($null -ne $facts){
        foreach($fact in $Facts) {
            $Fact.psobject.properties | ForEach-Object {
                if ($propertiesToSkip -notcontains ($_.name.tostring().tolower())) {
                    $factsList += [PSCustomObject]@{title = $_.name.tostring(); value = $_.value.tostring()}
                }
            }
        }
    }
} else { # this is a resource health alert so we put together some useful information manually instead of just doing a raw dump
    if ($payload.data.essentials.configurationItems.count -gt 1) {
        $resourceGroupName = $payload.data.essentials.alertTargetIDs[0].split('/')[4]
    } else {
        $resourceGroupName = $payload.data.essentials.alertTargetIDs.split('/')[4]
    }
    $factsList += [PSCustomObject]@{title = "Resource Group";   value = $resourceGroupName}
    $factsList += [PSCustomObject]@{title = "Timestamp ";       value = $payload.data.alertContext.eventTimestamp}
    $factsList += [PSCustomObject]@{title = "Level";            value = $payload.data.alertContext.level}
    $factsList += [PSCustomObject]@{title = "Status";           value = $payload.data.alertContext.status}
    $factsList += [PSCustomObject]@{title = "Type";             value = $payload.data.alertContext.properties.type}
    $factsList += [PSCustomObject]@{title = "Cause";            value = $payload.data.alertContext.properties.cause}
    $factsList += [PSCustomObject]@{title = "OperationId";      value = $payload.data.alertContext.operationId}
    $factsList += [PSCustomObject]@{title = "CorrelationID";    value = $payload.data.alertContext.correlationId}
}

$factsSection = New-Object -type psobject
$factsSection | Add-Member -MemberType NoteProperty -Name 'type' -Value 'FactSet'
$factsSection | Add-Member -MemberType NoteProperty -Name 'facts' -Value @($factsList)

# -------------------   Build the Raw Payload section ------------------
#
# This is a section that will contain the full JSON payload of the incoming webhook.  This is useful for debugging

$rawPayloadSection = New-Object -TypeName psobject
$rawPayloadSection | Add-Member -MemberType NoteProperty -Name 'type' -Value 'TextBlock'
$rawPayloadSection | Add-Member -MemberType NoteProperty -Name 'wrap' -Value $true
$rawPayloadSection | Add-Member -MemberType NoteProperty -Name 'separator' -Value $true
$rawPayloadSection | Add-Member -MemberType NoteProperty -Name 'isVisible' -Value $true
$rawPayloadSection | Add-Member -MemberType NoteProperty -Name 'text' -Value ($payload | ConvertTo-Json -Depth 25)

# ------------------  Build the ActionSet (buttons) ------------------

$goThereButtonName = ($isServiceHealthAlert ? "Go to Service Health" : "Go to Resource")

if ($isServiceHealthAlert) {
    $alertPortalUrl = "https://portal.azure.com/#view/Microsoft_Azure_Health/AzureHealthBrowseBlade/~/serviceIssues"
} else {
    if ($payload.data.essentials.alertTargetIDs.count -gt 1) {
        # make the link point to the first resource listed in the alertTargetIDs array
        $alertPortalUrl = "https://portal.azure.com/#@" + $env:tenantId + "/resource" + $payload.data.essentials.alertTargetIDs[0]
    } else {
        # only one element so no need for the array reference.
        $alertPortalUrl = "https://portal.azure.com/#@" + $env:tenantId + "/resource" + $payload.data.essentials.alertTargetIDs
    }
}

$goToAlertButton = New-Object -TypeName psobject
$goToAlertButton | Add-Member -MemberType NoteProperty -Name 'type' -Value 'Action.OpenUrl'
$goToAlertButton | Add-Member -MemberType NoteProperty -Name 'title' -Value $goThereButtonName
$goToAlertButton | Add-Member -MemberType NoteProperty -Name 'url' -Value $alertPortalUrl

# ------------------  Assemble the AdaptiveCard object ----------------
##

# Now assemble the card into a single object with the correct structure

# Body components
$content = New-Object -TypeName psobject
$content | Add-Member -MemberType NoteProperty -Name '$schema' -Value 'http://adaptivecards.io/schemas/adaptive-card.json'
$content | Add-Member -MemberType NoteProperty -Name 'type' -Value 'AdaptiveCard'
$content | Add-Member -MemberType NoteProperty -Name 'version' -Value '1.5'
$content | Add-Member -MemberType NoteProperty -Name 'body' -Value @($headerSection, $detailsSection, $factsSection, $rawPayloadSection)
$content | Add-Member -MemberType NoteProperty -Name 'actions' -Value @($goToAlertButton)

# Final Assembly - wrap it up
$attachments = New-Object -TypeName psobject
$attachments | Add-Member -MemberType NoteProperty -Name 'contentType' -Value 'application/vnd.microsoft.card.adaptive'
# $attachments | Add-Member -MemberType NoteProperty -Name 'contentUrl' -Value $null
$attachments | Add-Member -MemberType NoteProperty -Name 'content' -Value $content

$adaptiveCard = New-Object -TypeName psobject
$adaptiveCard | Add-Member -MemberType NoteProperty -Name 'type' -Value 'message'
$adaptiveCard | Add-Member -MemberType NoteProperty -Name 'attachments' -Value @($attachments)

### Send the message card to Teams

# Now that we have the message card, convert it to JSON so it can be sent as the body of the outgoing webhook
$adaptiveCardJSON = $adaptiveCard | ConvertTo-Json -Depth 25

####### Now that the MessageCard is complete, send the outgoing webhook to post the card

invoke-webrequest -method POST -uri $env:webhookuri -body $adaptiveCardJSON -ContentType 'application/json'

# Associate values to output bindings by calling 'Push-OutputBinding'.
# This sets the response code for the function to 200 OK and dumps the generated card into the output as JSON
Push-OutputBinding -Name Response -Value ([HttpResponseContext]@{
    StatusCode = [HttpStatusCode]::OK
    Body = $adaptiveCardJSON
})

# uncomment to dump the generated card (object) as output for debugging or other stuff.
# $adaptiveCard
